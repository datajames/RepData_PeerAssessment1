5+7
source('/james/Coursera/R Programming/exercise1/corr.R')
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",100)
getwd()
setwd("/james/Coursera/R Programming/exercise1")
ls
corr("specdata",100)
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",100)
corr("specdata",100)
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",100)
corr("specdata",5000)
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",5000)
corr("specdata",100)
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",100)
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",100)
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",100)
cc <- corr("specdata",100)
source('/james/Coursera/R Programming/exercise1/corr.R')
cc <- corr("specdata",100)
cc
cor(cc$sulfate,cc$nitrate)
source('/james/Coursera/R Programming/exercise1/corr.R')
cor(cc$sulfate,cc$nitrate)
corr("specdata",100)
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",100)
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",100)
source('/james/Coursera/R Programming/exercise1/corr.R')
corr("specdata",100)
cr <- corr("specdata", 150)
head(cr)
summary(cr)
cr <- corr("specdata", 400)
head(cr)
cr <- corr("specdata", 5000)
summary(cr)
length(cr)
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
9
submit()
submit()
source('/james/Coursera/R Programming/exercise1/corr.R')
source('/james/Coursera/R Programming/exercise1/corr.R')
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R')
cm <- makeCacheMatrix(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2))
matrixInverse <- cacheSolve(cm)
matrixInverse
cm
myfunc<- function(){ a <<- 5}
myfunc()
a
myfunc()
myfunc<- function(){ a <<- 5}
myfunc()
a <- 10
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(c(1,2,3,4,5,6,6,7,8,9,10))
makeCacheMatrix(matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE))
5+7
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R')
mdat <- matrix(c(1,2,3, 0,4,5, 1, 0, 6), nrow = 3, ncol = 3)
x <- makeCacheMatrix(mdat)
cacheSolve(x)
mdat <- matrix(rbind(c(1, -1/4), c(-1/4, 1)))
mdat
solve(c)
m <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE)
solve(m)
source('~/.active-rstudio-document')
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R')
m <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE)
x <- makeCacheMatrix(m)
cacheSolve(x)
cacheSolve(x)
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R')
ls()
class(x)
x$get
x$getInverse()
s$get()
x$get()
solve(x$get())
class(x)
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R')
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R')
m <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE)
x <- makeCacheMatrix(m)
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R')
x <- makeCacheMatrix(m)
cacheSolve(x)
cacheSolve(x)
source('/james/Dropbox/Coursera/R Programming/ProgrammingAssignment2/cachematrix.R')
setwd("/james/Dropbox/Coursera/Data Science Specialisation/Reproducible Research/RepData_PeerAssessment1")
# unzip the activity.zip file into the current directory
unzip("./activity.zip",exdir="./")
# read the activity.csv file in and define the column classes
activitydata <- read.csv(file = "activity.csv", na.strings="NA",colClasses=c("integer","POSIXct","integer"))
# create a clean data set with the NA's ommitted
activitydata.clean <- na.omit(activitydata)
# create an array which holds the sum of steps per day
temp<-tapply(activitydata.clean$steps,format(activitydata.clean$date,"%Y-%m-%d"),sum)
# draw the historgram and set the labes for axis and title
hist(temp,xlab="Sum steps per day",ylab="Frequency", col = "light blue",labels=TRUE,main="Histogram of the total number of steps taken each day")
# calculate the mean and store in variable for reporting and then also display
steps.mean <- mean(temp[!is.na(temp)])
print(steps.mean)
# calculate the median and store in variable for reporting and then also display
steps.median <- median(temp[!is.na(temp)])
print(steps.median)
aveDailyPattern <- aggregate(steps ~ interval, activitydata.clean, mean)
plot(aveDailyPattern,type="l",ylab="Average steps")
# use which.max() to get the row number with the max steps and use this to retrieve the interval from the vector
aveDailyPattern[which.max(aveDailyPattern$steps),1]
sum(!complete.cases(activitydata))
filled_data <- merge(activitydata,aveDailyPattern,by="interval")
View(filled_data)
filled_dara$steps.x[is.na(filled_data$steps.x)] <- filled_data$steps.y[is.na(filled_data$steps.x)]
filled_data$steps.x[is.na(filled_data$steps.x)] <- filled_data$steps.y[is.na(filled_data$steps.x)]
View(filled_data)
View(filled_data)
filled_data <- filled_data[order(filled_data$date)]
filled_data <- filled_data[order(filled_data$date),]
View(filled_data)
barplot(daily_filled$steps.x, names.arg=daily_filled$date,
main="Total number of steps taken each day (Filled Data)",
xlab="Date", ylab="Steps", col="red")
daily_filled <- ddply(filled_data, .(date), summarize, steps=sum(steps))
activitydata[1,2]
class(activitydata[1,2])
activity <- read.csv("/james/Dropbox/Coursera/Data Science Specialisation/Reproducible Research/RepData_PeerAssessment1/activity.csv", stringsAsFactors=FALSE)
View(activity)
rename(aveDailyPattern,c("steps"="aveSteps"))
names(aveDailyPattern)[names(aveDailyPattern)=="steps"] <- "aveSteps"
View(aveDailyPattern)
#
filled_data <- merge(activitydata,aveDailyPattern,by="interval")
filled_data$steps[is.na(filled_data$steps)] <- filled_data$aveSteps[is.na(filled_data$steps)]
filled_data <- filled_data[order(filled_data$date),]
head(filled_data)
head(activitydata)
# no need to check for any NA values as these were filled in the previous step
# create an array which holds the sum of steps per day
temp_filled<-tapply(filled_data$steps,format(filled_data$date,"%Y-%m-%d"),sum)
# draw the historgram and set the labes for axis and title
hist(temp_filled,xlab="Sum steps per day",ylab="Frequency", col = "light green",labels=TRUE,main="Histogram of the total number of steps taken each day with filled data")
temp
temp_filled
hist_filled <- hist(temp_filled,xlab="Sum steps per day",ylab="Frequency", col = "light green",labels=TRUE,main="Histogram of the total number of steps taken each day with filled data")
hist_raw <- hist(temp,xlab="Sum steps per day",ylab="Frequency", col = "light blue",labels=TRUE,main="Histogram of the total number of steps taken each day")
cbind.data.frame(hist_raw$breaks,hist_raw$counts,hist_filled$counts)
hist_raw <- hist(temp,xlab="Sum steps per day",ylab="Frequency", col = "light blue",labels=TRUE,main="Histogram of the total number of steps taken each day")
cbind.data.frame(hist_raw$mids,hist_raw$counts,hist_filled$counts)
cbind.data.frame(hist_raw$mids,hist_raw$counts,hist_filled$counts,hist_filled$counts-hist_raw$counts)
cbind.data.frame(hist_raw$breaks[1:6],hist_raw$counts,hist_filled$counts,hist_filled$counts-hist_raw$counts)
cbind.data.frame(hist_raw$breaks[2:6],hist_raw$counts,hist_filled$counts,hist_filled$counts-hist_raw$counts)
cbind.data.frame(hist_raw$breaks[2:6],hist_raw$counts,hist_filled$counts,hist_filled$counts-hist_raw$counts)
diff_table <- cbind.data.frame(hist_raw$breaks[2:6],hist_raw$counts,hist_filled$counts,hist_filled$counts-hist_raw$counts)
names(diff_table) <- c("Upper Break #","Raw Data","Filled Data","Filled Data - Raw Data")
diff_table
# calculate the mean and store in variable for reporting and then also display
steps.mean.filled <- mean(temp_filled[!is.na(temp_filled)])
print(steps.mean.filled)
# calculate the median and store in variable for reporting and then also display
steps.median.filled <- median(temp_filled[!is.na(temp_filled)])
print(steps.median.filled)
names(filled_data[1,3])
filled_data[1,3]
class(filled_data[1,3])
filled_data[1,3]$mday
mydate = filled_data[1,3]
mydate
tapply(filled_data,filled_data[,3],sum)
weekend.days <- c("Saturday","Sunday")
as.factor(sapply(filled_data$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday")))
sapply(filled_data$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday"))
weekday.weekend <- sapply(filled_data$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday"))
filled_data$dayType <- as.factor(sapply(filled_data$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday")))
filled_data$dayType <- sapply(filled_data$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday"))
View(filled_data)
View(filled_data)
plot(aggregate(steps ~ interval, data=activitydata.clean, FUN=mean,subset=activitydata.clean$dayType="weekday"))
plot(aggregate(steps ~ interval, data=activitydata.clean, FUN=mean,subset=activitydata.clean$dayType=="weekday"))
plot(aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=activitydata.clean$dayType=="weekday"))
plot(aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday"))
plot(aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday",type="l"))
plot(aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday",type="l"))
plot(aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday"),type="l")
# we will need a two row container to place plots in
par(mfrow=c(2,1))
# calculate the average pattern for a weekday
aveWeekDayPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday")
# now create the weekday plot
plot(aveWeekDayPattern,type="l")
# create a new plot for the weekend
aveWeekEndPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekend")
plot(aveWeekEndPattern,type="l")
activitydata$dayType <- sapply(activitydata$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday"))
# we will need a two row container to place plots in
par(mfrow=c(2,1))
# calculate the average pattern for a weekday
aveWeekDayPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday")
# now create the weekday plot
plot(aveWeekDayPattern,type="l")
activitydata$dayType <- sapply(activitydata$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday"))
points(aggregate(steps ~ interval, data=activitydata, FUN=mean,subset=activitydata$dayType=="weekday"),type="l")
# create a new plot for the weekend
aveWeekEndPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekend")
plot(aveWeekEndPattern,type="l")
par(mfrow=c(1,1))
# calculate the average pattern for a weekday
aveWeekDayPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday")
# now create the weekday plot
plot(aveWeekDayPattern,type="l")
activitydata$dayType <- sapply(activitydata$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday"))
points(aggregate(steps ~ interval, data=activitydata, FUN=mean,subset=activitydata$dayType=="weekday"),type="l")
View(activitydata)
View(activitydata)
# we will need a two row container to place plots in
par(mfrow=c(2,1))
# calculate the average pattern for a weekday
aveWeekDayPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday")
# now create the weekday plot
plot(aveWeekDayPattern,type="l")
# create a new plot for the weekend
aveWeekEndPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekend")
plot(aveWeekEndPattern,type="l")
library(lattice)
as.factor(aveWeekDayPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday"))
as.factor(aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday"))
as.factor(sapply(filled_data$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday")))
filled_data$dayType <- as.factor(sapply(filled_data$date, function(x) ifelse(weekdays(x) %in% weekend.days,"weekend","weekday")))
attach(filled_data)
ls()
xyplot(aveSteps|dayType,
main="Ave Steps",
ylab="Steps", xlab="Interval")
detach(filled_data)
attach(filled_data)
xyplot(steps~interval)
xyplot(steps~interval,type=l)
xyplot(steps~interval,type="l")
xyplot(steps~interval|dayType,type="l")
xyplot(steps~interval|dayType,type="l",layout=c("2,1"))
xyplot(steps~interval|dayType,type="l",layout=c(2,1))
xyplot(steps~interval|dayType,type="l",layout=c(1,2))
xyplot(steps~interval|dayType,type="l",layout=c(1,2),formula = mean)
xyplot(steps~interval|aggregate(steps ~ interval, data=filled_data, FUN=mean),type="l",layout=c(1,2))
xyplot(steps~interval|,type="l",layout=c(1,2),data=aggregate(steps ~ interval, data=filled_data, FUN=mean)
xyplot(steps~interval|,type="l",layout=c(1,2),data=(aggregate(steps ~ interval, data=filled_data, FUN=mean)))
xyplot(steps~interval|dayType,type="l",layout=c(1,2),data=(aggregate(steps ~ interval, data=filled_data, FUN=mean)))
xyplot(steps~interval|sapply(filled_data$date, function(x) ifelse(weekdays(x) %in% weekend,"weekend","weekday"),type="l",layout=c(1,2),data=(aggregate(steps ~ interval, data=filled_data, FUN=mean)))
)
xyplot(steps~interval | dayType,
type="l",
layout=c(1,2),
data=(aggregate(steps ~ interval, data=filled_data, FUN=mean))
)
# we will need a two row container to place plots in
par(mfrow=c(2,1))
# calculate the average pattern for a weekday
aveWeekDayPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday")
# create a new plot for the weekend
aveWeekEndPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekend")
aveWeekEndPattern$dayType <- rep("weekend",nrow(aveWeekEndPattern))
aveWeekDayPattern$dayType <- rep("weekday",nrow(aveWeekDayPattern))
data <- rbind(aveWeekDayPattern,aveWeekEndPattern)
ls()
detach(filled_data)
with(data,xyplot(steps~interval|dayType,type="l",layout=c(1,2)))
# we will need a two row container to place plots in
par(mfrow=c(2,1))
# create a new average aggregate for weekday
aveWeekDayPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday")
aveWeekDayPattern$dayType <- rep("weekday",nrow(aveWeekDayPattern))
# create a new average aggregate for weekend
aveWeekEndPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekend")
# add a column with the
aveWeekEndPattern$dayType <- rep("weekend",nrow(aveWeekEndPattern))
# merge to a single data frame and plot by dayType factor using lattice library
library(lattice)
data <- rbind(aveWeekDayPattern,aveWeekEndPattern)
with(data,xyplot(steps~interval|dayType,type="l",layout=c(1,2),xlab="Interval in minutes past midnight",ylab="steps",main"Comparison of weekday and weekend step averages through the day"))
with(filled_data,tapply(date,date+(interval*60)))
# unzip the activity.zip file into the current directory
unzip("./activity.zip",exdir="./")
# read the activity.csv file in and define the column classes
activitydata <- read.csv(file = "activity.csv", na.strings="NA",colClasses=c("integer","POSIXct","integer"))
# create a clean data set with the NA's ommitted
activitydata.clean <- na.omit(activitydata)
# create an array which holds the sum of steps per day
temp<-tapply(activitydata.clean$steps,format(activitydata.clean$date,"%Y-%m-%d"),sum)
# draw the historgram and set the labes for axis and title
hist_raw <- hist(temp,xlab="Sum steps per day",ylab="Frequency", col = "light blue",labels=TRUE,main="Histogram of the total number of steps taken each day")
# calculate the mean and store in variable for reporting and then also display
steps.mean <- mean(temp[!is.na(temp)])
print(steps.mean)
# calculate the median and store in variable for reporting and then also display
steps.median <- median(temp[!is.na(temp)])
print(steps.median)
# find the mean daily pattern for each interval period
aveDailyPattern <- aggregate(steps ~ interval, activitydata.clean, mean)
# rename the steps column to aveSteps to make it more representative
names(aveDailyPattern)[names(aveDailyPattern)=="steps"] <- "aveSteps"
# plot a line graph of the average daily steps pattern
plot(aveDailyPattern,type="l",ylab="Average steps",main="Average Daily Activity Pattern")
# use which.max() to get the row number with the max steps and use this to retrieve the interval from the vector
aveDailyPattern[which.max(aveDailyPattern$aveSteps),1]
sum(!complete.cases(activitydata))
# merge the activitydata dataframe and the aveDailyPattern dataframe
# this gives four columns interval,steps,date and aveSteps
# this may then be used for comparison and if there is an NA value in steps use the aveSteps for that interval
filled_data <- merge(activitydata,aveDailyPattern,by="interval")
filled_data$steps[is.na(filled_data$steps)] <- filled_data$aveSteps[is.na(filled_data$steps)]
# order the data set by the date
filled_data <- filled_data[order(filled_data$date),]
# no need to check for any NA values as these were filled in the previous step
# create an array which holds the sum of steps per day
temp_filled<-tapply(filled_data$steps,format(filled_data$date,"%Y-%m-%d"),sum)
# draw the historgram and set the labes for axis and title
hist_filled <- hist(temp_filled,xlab="Sum steps per day",ylab="Frequency", col = "light green",labels=TRUE,main="Histogram of the total number of steps taken each day with filled data")
# create a dataframe from the histogram data and calculate the difference between the values
# not a subset of the hist$breaks was used as this is always $counts+1.  The upper bound of the breaks was chosen for the table
diff_table <- cbind.data.frame(hist_raw$breaks[2:6],hist_raw$counts,hist_filled$counts,hist_filled$counts-hist_raw$counts)
# give the table some more meaningful names
names(diff_table) <- c("Upper Break #","Raw Data","Filled Data","Filled Data - Raw Data")
# print the values
print(diff_table)
# calculate the mean and store in variable for reporting and then also display
steps.mean.filled <- mean(temp_filled[!is.na(temp_filled)])
print(steps.mean.filled)
# calculate the median and store in variable for reporting and then also display
steps.median.filled <- median(temp_filled[!is.na(temp_filled)])
print(steps.median.filled)
# store the values for weekend days
weekend <- c("Saturday","Sunday")
# now iterate through the the filled_data dataframe and test to see if the weekdays(filled_data$date) is in the weekend vector or not
weekday.weekend <- as.factor(sapply(filled_data$date, function(x) ifelse(weekdays(x) %in% weekend,"weekend","weekday")))
# add this as a new column in the filled_data dataframe
filled_data$dayType <- weekday.weekend
# we will need a two row container to place plots in
par(mfrow=c(2,1))
# create a new average aggregate for weekday
aveWeekDayPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekday")
aveWeekDayPattern$dayType <- rep("weekday",nrow(aveWeekDayPattern))
# create a new average aggregate for weekend
aveWeekEndPattern <- aggregate(steps ~ interval, data=filled_data, FUN=mean,subset=filled_data$dayType=="weekend")
# add a column with the
aveWeekEndPattern$dayType <- rep("weekend",nrow(aveWeekEndPattern))
# merge to a single data frame and plot by dayType factor using lattice library
library(lattice)
data <- rbind(aveWeekDayPattern,aveWeekEndPattern)
with(data,xyplot(steps~interval|dayType,type="l",layout=c(1,2),xlab="Interval in minutes past midnight",ylab="steps",main="Comparison of weekday and weekend step averages through the day"))
with(filled_data,tapply(date,date+(interval*60)))
apply(filled_data$date,filled_data$date+(filled_data$interval*60))
apply(filled_data$date,FUN=filled_data$date+(filled_data$interval*60))
with(filled_data,date+interval)
with(filled_data,date+(interval*60)
)
aveDailyPattern$datetime <- with(aveDailyPattern,date+(interval*60)
aveDailyPattern$datetime <- with(aveDailyPattern,date+(interval*60)
# use which.max() to get the row number with the max steps and use this to retrieve the interval from the vector
aveDailyPattern[which.max(aveDailyPattern$aveSteps),1]
# add datetime column using interval
aveDailyPattern$datetime <- with(aveDailyPattern,date+(interval*60))
aveDailyPattern[which.max(aveDailyPattern$aveSteps),aveDailyPattern$datetime]
# use which.max() to get the row number with the max steps and use this to retrieve the interval from the vector
maxsteps.time <- aveDailyPattern[which.max(aveDailyPattern$aveSteps),1]
d <- as.Date("1970-01-01")
p <- as.POSIXlt(d)
p + (maxsteps.time*60)
# use which.max() to get the row number with the max steps and use this to retrieve the interval from the vector
maxsteps.time <- aveDailyPattern[which.max(aveDailyPattern$aveSteps),1]
d <- as.Date("1970-01-01")
p <- as.POSIXlt(d)
format(p + (maxsteps.time*60),"%A")
# use which.max() to get the row number with the max steps and use this to retrieve the interval from the vector
maxsteps.time <- aveDailyPattern[which.max(aveDailyPattern$aveSteps),1]
d <- as.Date("1970-01-01")
p <- as.POSIXlt(d)
format(p + (maxsteps.time*60),"%T")
